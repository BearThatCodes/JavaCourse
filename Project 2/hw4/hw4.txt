Output:
-------------------------------------------------------------------
NO_LOCKING, 1 -- OK: 6662.095945 transactions/msec
NO_LOCKING, 2 -- BROKEN: 5348.329319 transactions/msec	Expected total balances: 100000	Actual: 18507
NO_LOCKING, 5 -- BROKEN: 228.588366 transactions/msec	Expected total balances: 100000	Actual: 591
NO_LOCKING, 10 -- BROKEN: 90.785523 transactions/msec	Expected total balances: 100000	Actual: 345
NO_LOCKING, 20 -- BROKEN: 49.995278 transactions/msec	Expected total balances: 100000	Actual: 185
LOCK_BANK, 1 -- OK: 6167.376756 transactions/msec
LOCK_BANK, 2 -- OK: 3764.665286 transactions/msec
LOCK_BANK, 5 -- OK: 3356.301615 transactions/msec
LOCK_BANK, 10 -- OK: 3362.606986 transactions/msec
LOCK_BANK, 20 -- OK: 3255.009685 transactions/msec
LOCK_ACCOUNTS, 1 -- OK: 5425.913517 transactions/msec
LOCK_ACCOUNTS, 2 -- OK: 6107.583968 transactions/msec
LOCK_ACCOUNTS, 5 -- OK: 8249.311062 transactions/msec
LOCK_ACCOUNTS, 10 -- OK: 9413.580335 transactions/msec
LOCK_ACCOUNTS, 20 -- OK: 9574.148940 transactions/msec

Process finished with exit code 0
-------------------------------------------------------------------

Questions:
-------------------------------------------------------------------
1. Why does the NO_LOCKING test succeed for one thread and fail for 2-20 threads? (It is possible that you will see some successes for larger number of threads. But if you see no failures, then something is amiss.)

Since no other thread can jump in in between the balance check and the actual withdrawl, overdrafts, if any, are handled appropriately (with an exception). Once we add more threads, it becomes increasingly likely that control will pass from one thread to another in the middle of the withdraw method thus breaking the balance check that occurs.

I would not have been suprised to see another thread or two succeed were I to run this again since, depending on how much each thread wants to withdraw, there might be enough for several threads to withdraw their desired amounts even though their balance checks will be outdated by the time the actual withdraw occurs.

-------------------------------------------------------------------

2. How do you explain the change in performance for LOCK_BANK as threads increase from 1 to 20.

With only a single thread of LOCK_BANK running, each transfer must be run in sequence with each other transfer. This is essentially the same as what would happen in a non-threaded appication where each transfer was called in a loop. Once we add additional threads, while we're still running transfers in sequence, each thread must wait on the single Bank resource before it can run its transfer method. Ultimately this means that we get all of the overhead of a multithreaded appication without any of the performance benefits.

-------------------------------------------------------------------

3. How does the performance of LOCK_BANK compare to that of LOCK_ACCOUNTS? How do you explain this?

LOCK_BANK is significantly less efficient than LOCK_ACCOUNTS. This is because, in LOCK_BANK, each transfer transaction must wait on the single Bank object before it can be run. With LOCK_ACCOUNTS, transfer operations only need to wait for an individual Account to be unlocked. This means that, not only is it much less likely that any given transfer will pertain to a locked object, but any objects (Accounts) that *are* locked will be in that state for a much shorter period of time than a locked Bank object would. This is because the Bank only needs to run a single Account method before releasing the Account monitor, rather than the performing the full transfer (calling two Account methods) before releasing the Bank monitor.

-------------------------------------------------------------------